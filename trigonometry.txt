// Tables and arrays
long			sinCosTable[ANGLES + ANGLES/4];
long*			sinTable = sinCosTable;
long*			cosTable = &(sinCosTable[ANGLES/4]);
unsigned int	sinAcosTable[TRIGONOMETRY];
int				endPointArray[2][SCREEN_HEIGHT];

// Initialize tables and arrays
void initArrays()
{
	int i;
	long double x, real;
	
	// Init sinCosTable
	for (i = 0; i < ANGLES + ANGLES/4; i++)
	{
		real = sin((i * 2 * M_PI) / ANGLES);
		sinCosTable[i] = real * (1 << FRACTIONAL_PART);
	}

	// Init sin(acos(x)) table
	for (i = 0; i < TRIGONOMETRY-1; i++)
	{
		x = (long double)i / TRIGONOMETRY;
		real = sqrt(1 - x*x);
		// real = sin(acos((double)i / TRIGONOMETRY));
		sinAcosTable[i] = real * (1 << FRACTIONAL_PART);
	}
	
	// Init endpoint array
	memset(endPointArray, 0, sizeof(endPointArray));
}

// Value multiplied by sin of angle
int sinAngle(int value, int angle)
{
	long long temp;
	temp = (long long)value * (long long)(1 << FRACTIONAL_PART); // to fixed point
	temp *= (long long)sinTable[angle];	// multiply with sin
	temp >>= FRACTIONAL_PART;			// bitshift correction
	temp += FRACTIONAL_PART * 160;
	temp /= (1 << FRACTIONAL_PART);		// convert to normal	
	return (int)temp;					// cast to integer
}

// Value multiplied by cos of angle
int cosAngle(int value, int angle)
{
	long long temp;
	temp = (long long)value * (long long)(1 << FRACTIONAL_PART); // to fixed point
	temp *= (long long)cosTable[angle];	// multiply with cos
	temp >>= FRACTIONAL_PART;			// bitshift correction
	temp += FRACTIONAL_PART * 160;
	temp /= (1 << FRACTIONAL_PART);		// convert to normal	
	return (int)temp;					// cast to integer
}